package com.mt.designpattern.state;

/**
 * 状态模式
 * 定义：状态模式把研究的对象的行为包装在不同状态对象里，每一个状态对象都是一个抽象状态的子类。其目的是让一个对象在起内部状态改变时行为也随之改变。其包含三个角色，如：
 * 1.环境(Context)角色，也成上下文：定义客户端所感兴趣的接口，并且保留一个具体状态类的实例。这个具体状态类的实例给出此环境对象的现有状态。
 * 2.抽象状态(State)角色：定义一个接口，用以封装环境（Context）对象的一个特定的状态所对应的行为。
 * 3.具体状态(ConcreteState)角色：每一个具体状态类都实现了环境（Context）的一个状态所对应的行为。
 *
 * 例子: 以一次请假申请为例，有驳回（0）,提交审批(1)、一审(2)、二审(3)、审批通过(4)四种状态，从提交审批（1）开始，假设有两种操作，第一种是推进，第二种是驳回，推进和回退都必须按照提交审批、一审、二审、审批通过
 * 依次顺序或倒序进行，用程序完成。
 * 首先常规思路可能是这样的，如：{@link Routine}。
 * 使用状态模式完成，跟着状态模式的定义走，首先定义一个抽象的状态类{@link State},根据状态依次定义其子类{@link CmmitState}..... 定义环境(Context)角色 {@link Context}
 *
 * 说一下策略模式和状态模式区别吧：
 * 策略模式：其思想是针对一组算法，将每一种算法都封装到具有共同接口的独立的类中，从而是它们可以相互替换。策略模式的最大特点是使得算法可以在不影响客户端的情况下发生变化，从而改变不同的功能
 * 状态模式：允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。
 * 在很多情况下，一个对象的行为取决于一个或多个动态变化的属性，这样的属性叫做状态，这样的对象叫做有状态的(stateful)对象，这样的对象状态是从事先定义好的一系列值中取出的。当一个这样的对象与外部事件产生互动时，其内部状态就会改变，从而使得系统的行为也随之发生变化。
 *
 * 使用场景
 * 策略模式：策略模式的Strategy类层次为Context定义了一系列的可供重用的算法或行为。继承有助于析取出这些算法中的公共功能。在实践中，我们发现可以用它来封装几乎任何类型的规则，只要在分析过程中听到需要在不同时间应用不同的业务规则，就可以考虑使用策略模式处理这种变化的可能性。
 * 状态模式：状态模式主要解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况。把状态的判断逻辑转移到表示不同状态的一系列类当中，可以把复杂的判断逻辑简化。当一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为时，就可以考虑使用状态模式了。
 *
 *
 * author: liqm
 * 2019-11-05
 */
public class StateTest {

    public static void main(String[] args) {

        /** 常规思路 */
        Routine routine = new Routine();
        routine.setLeave(new Leave("1"));
//        routine.pushOn();
//        routine.pushOn();
//        routine.reject();
//        routine.pushOn();
//        routine.reject();
        System.out.println(".....................................");
        /** 状态模式 */
        Context context = new Context(new CmmitState());
        context.pushOn();
        context.pushOn();
        context.reject();
        context.pushOn();
        context.pushOn();
        context.pushOn();
    }

}
